<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5G plot prototyping @alreylz</title>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap"
        rel="stylesheet">



    <link rel="stylesheet" href="./index.css" />


    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="/main.js" type="module"></script>
    <script src="/EventManager.js" type="module"></script>
</head>

<body>
    <header class="header">
        <h1>Mapping client for 5G AR app </h1>
    </header>
    <main>


        <form class="what-to-plot-selection">
            <div class="room-choose-container scrollable-max-size">
                <label>Room visualization:</label>
                <select data-dynamic="roomsSelect">
                    <option>Select a room to visualize</option>
                </select>
            </div>

            <ul class="session-choose scrollable-max-size" data-dynamic="sessions">
                <li class="session-item design-only">
                    <label>
                        <span class="session-name">Example session</span>
                    </label>
                    <input type="checkbox" data-id="" />
                </li>
                <!--THIS ID FILLED DYNAMICALLY-->
            </ul>
        </form>


        <h1>Currently displaying</h1>
        <div id="measurements">
            <!--THIS ID FILLED DYNAMICALLY-->
        </div>

        <section class="grid-form-map">
            <form class="viz-controls-form">
                Adjust Plot Origin
                <input name="latitude" type="text" placeholder="latitude [-90, 90]" required />
                <input name="longitude" type="text" placeholder="longitude [-180, 180]" required />
                <input name="rotation" type="text" placeholder="rotation (optional)" />
                <button type="submit" class="button interactable"> Reset</button>
            </form>
            <div id="map"></div>
        </section>



        <section>
            Maybe i could add a table showing the measurements and some simple plots
            <table>
            </table>

        </section>
    </main>


    <footer class="footer">
        <a href="https://espaciosoa.com/">&#169; EspacioSOA</a>
        <pre>Developed by <a href="https://alejandro-rey.me" >@alreylz</a></pre>
        <p> Julian Camarillo 26, 6, 28037 Madrid</p>
    </footer>






    <script defer type="module">

        import {
            localToGeo, validateLat, validateLong, isNumber, rotatePointMap,
            getMeasurements, getSessions, getRooms
        }
            from "./main.js"
        import { EventManager } from "./EventManager.js"


        import JSUtils from "./Helpers.js"

        const allSessions = await getSessions()
        console.log(allSessions)

        const allMeasurements = await getMeasurements();
        console.log(allMeasurements)

        const allRooms = await getRooms();
        console.log(allRooms)



        //Notify when active things happen here.







        // GLOBAL STATE
        const room = allRooms[0]
        // TODO: should allow to display from different sessions.
        const chosenSession = allSessions[2]
        const sessionMeasurements = allMeasurements.filter(ms => { return ms.measurementSession == chosenSession._id })
        // END GLOBAL STATE

        class PageState extends EventManager {

            constructor(name = "") {
                super();

                this._activeRoom = null;
                this._activeSessions = [];
                this._activeMeasurements = [];


                this.subscribe("onChangeState", (state) => console.log("@state", state))
            }


            #overallStateChange() {
                this._dispatch("onChangeState", this)
            }

            set setActiveRoom(room) {
                this._activeRoom = room;
                this._dispatch("onActiveRoomChanged", this._activeRoom);


                this.#overallStateChange()
            }


            

            addSession(session) {
                this._activeSessions.push(session)
                this._dispatch("onActiveSessionsChanged", this._activeSessions)
                this.#overallStateChange()

            }
            removeSession(session) {
                this._activeSessions.pop(session)
                this._dispatch("onActiveSessionsChanged", this._activeSessions)
                this.#overallStateChange()

            }



            set setActiveSessions(sessions) {
                this._activeSessions = sessions
                this._dispatch("onActiveSessionsChanged", this._activeSessions)
                this.#overallStateChange()

            }

            set setActiveMeasurements(measurements) {
                this._activeMeasurements = measurements;
                this._dispatch("onMeasurementsChanged", this._activeMeasurements);
                this.#overallStateChange()

            }


        }


        // trying to encapsulate global state in a class
        const myState = new PageState("visualization_state")

        console.log("My state")
        console.log(myState)



        myState.subscribe("onChangeState", (state) => {

        })

        //TESTING OF THE MY STATE
        myState.subscribe("onActiveSessionsChanged", (activeSessions) => {
            console.log("ACTIVE SESSIONS CHANGED", activeSessions)
        })

        myState.subscribe("onActiveRoomChanged", (activeRoom) => {
            console.log("ACTIVE ROOM CHANGED", activeRoom)
        })

        myState.subscribe("onMeasurementsChanged", (activeMeasurements) => {

            console.log("ACTIVE MEASUREMENTS CHANGED", activeRoom)
        })






        const sessionsCheckboxContainer = document.querySelector("[data-dynamic=sessions]")
        const roomOptionsSelect = document.querySelector("[data-dynamic=roomsSelect]")



        //For a given array of sessions, shows them as checkboxes
        function showSessionsAsCheckboxes(parent, dataArray) {

            const option_HTML_Template = `<li class="session-item">
                    <label>
                        <span class="session-name">{{sessionId}}</span> |
                        <span class="session-date">{{sessionDate}}</span>
                    </label>
                    <input type="checkbox" data-type="session" data-id="{{sessionId}}" />
                </li>`



            const allSessionCheckboxes = []


            dataArray.forEach(data => {
                const myCheckboxes = JSUtils.replaceTemplatePlaceholders(option_HTML_Template,
                    {
                        sessionDate: data.timestamp,
                        sessionId: data._id,
                    });


                const checkboxDOM_Node = JSUtils.txtToHTMLNode(myCheckboxes)
                //TODO: Event subscription pending here
                console.log("Adding onChange events to checkboxes")
                checkboxDOM_Node.addEventListener("change", (ev) => {
                    const checkbox = ev.target
                    const isActive = checkbox.checked
                    console.log(checkbox.dataset)
                    const toActivateThing = checkbox.dataset.type
                    const toActivateId = checkbox.dataset.id
                    // myState.setActiveSessions()
                    console.log(`${checkbox} ${toActivateThing} CHANGED isActive ? ${isActive} | id: ${toActivateId}  `)


                    isActive ?
                        myState.addSession(allSessions.filter(e => e._id === toActivateId)[0])
                        : myState.removeSession(allSessions.filter(e => e._id === toActivateId)[0])

                })

                allSessionCheckboxes.push(checkboxDOM_Node)
            })




            parent.replaceChildren(...allSessionCheckboxes)
        }


        //Given the rooms endpoint, shows all the possible rooms as select options
        function showRoomsAsSelectOptions(selectItem, rooms) {

            const roomOptionHtmlTemplate = `<option data-id={{roomId}}>
                    {{roomName}}
                </option>`


            const allRoomsAsOptions = []

            rooms.forEach(r => {

                const myOptionNode = JSUtils.replaceTemplatePlaceholders(roomOptionHtmlTemplate,
                    {
                        roomId: r._id,
                        roomName: r.name
                    });

                allRoomsAsOptions.push(JSUtils.txtToHTMLNode(myOptionNode))

            })


            selectItem.replaceChildren(...allRoomsAsOptions)

        }


        showRoomsAsSelectOptions(roomOptionsSelect, allRooms)
        showSessionsAsCheckboxes(sessionsCheckboxContainer, allSessions)


        //Showing in the page for which session I am showing info
        const myDivTemplate = `<section class="currently-displaying"> 
            <header>
                <h2> Room: <span class="room-name">{{room}}</span></h2>
                 <h3 > Session/s:  <span class="session-name">{{session}}</span> </h3>
            </header> 
                 <p> Measurements: {{measurements}} </p>       
              </section>`


        const myDiv = JSUtils.replaceTemplatePlaceholders(myDivTemplate, {
            room: `${room._id} | ${room.name} `,
            session: chosenSession._id,
            measurements: sessionMeasurements.length
        })

        const measurementsContainer = document.querySelector("#measurements")
        measurementsContainer.append(JSUtils.txtToHTMLNode(myDiv))

        function matchColorLevel(level) {

            let color = "#FFFFFF"
            switch (level) {
                case 0: color = "#FF8282"
                    break;
                case 1: color = "#FFC482"
                    break;
                case 2: color = "#F0FF82"
                    break;
                case 3: color = "#82FF8A"
                    break;
                case 4: color = "#82CBFF"
                    break;
            }
            return color

        }


        let origin = {
            lat: chosenSession.worldPosition.lat,
            lon: chosenSession.worldPosition.lon
        }

        console.log(origin)
        console.warn("@alreylz - USING ANONYMIZED ORIGIN")
        origin = { lat: 40.41523, lon: -3.70711 }







        // Init map
        const map = L.map('map').setView([origin.lat, origin.lon], 19);
        const tiles = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 22,
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        }).addTo(map);

        let layers = []


        const inputLat = document.querySelector("input[name=latitude]")
        inputLat.value = origin.lat
        const inputLong = document.querySelector("input[name=longitude]")
        inputLong.value = origin.lon

        const inputRot = document.querySelector("input[name=rotation]")

        const form = document.querySelector(".viz-controls-form")


        form.addEventListener("submit", (ev) => {
            console.log("Onsubmit ")

            ev.preventDefault()
            origin = {
                lat: validateLat(parseFloat(inputLat.value)),
                lon: validateLong(parseFloat(inputLong.value))
            }

            console.log("validated origin", origin)

            clearMapLayers()


            const angleConversion = parseFloat(inputRot.value)
            const angle = Number.isNaN(angleConversion) ? 0 : angleConversion;


            console.log("angle", angle)


            //TODO: Get shape of what I need every time
            let points = sessionMeasurements.map(measurement => { return { ...measurement.position, ...measurement.signalMeasurement } })



            renderMap(origin, points, angle)


        })


        let points = sessionMeasurements.map(measurement => { return { ...measurement.position, ...measurement.signalMeasurement } })

        renderMap(origin, points)





        function clearMapLayers() {
            layers.forEach((l) => {
                map.removeLayer(l)
            })
        }

        function renderMap(origin, points, rotation) {


            console.log("Rendering map ", origin)


            map.setView([origin.lat, origin.lon])
            // Example points to plot (Cartesian coordinates) 
            // Mocks the data that should be stored in the database and is to be used for visualization 
            // const points = [
            //     { x: -0.7928082, y: -0.9481621, z: -1.5327121, level: 0 },
            //     { x: 1.276402, y: -1.4514962, z: -1.4927666, level: 1 },
            //     { x: 1.8429325, y: -1.4484526, z: -0.74175, level: 1 },
            //     { x: 2.2791092, y: -1.4481357, z: -0.09217739, level: 1 },
            //     { x: 1.9964722, y: -1.4484534, z: 0.12878221, level: 1 },
            //     { x: 2.3124382, y: -1.4485171, z: 0.5447298, level: 1 },
            //     { x: 2.3496757, y: -1.60327, z: 0.43899673, level: 2 },
            //     { x: 2.9232445, y: -1.4835371, z: 0.7789793, level: 3 },
            //     { x: 3.0188122, y: -1.4834874, z: 0.94221646, level: 0 },
            //     { x: 2.5010853, y: -1.5031501, z: 1.5829906, level: 1 },
            //     { x: 2.250494, y: -1.5031159, z: 1.5310786, level: 4 },
            //     { x: 1.8547566, y: -1.4985006, z: 1.3673253, level: 3 },
            //     { x: 0.9731356, y: -1.4908487, z: 0.80070454, level: 2 },
            //     { x: 0.45117122, y: -1.4890068, z: 0.16238421, level: 1 },
            //     { x: 0.26037943, y: -1.1160464, z: -0.09716594, level: 1 },
            //     { x: 0.5252408, y: -1.1160513, z: -0.28890827, level: 1 },
            //     { x: 0.61974454, y: -1.1160265, z: -0.66309595, level: 1 }
            // ];







            const layerGroupOrigin = L.layerGroup().addTo(map);

            let myOriginPainted = L.circle(origin, {
                color: 'orange',
                fillOpacity: 0.5,
                radius: 0.5
            }).addTo(layerGroupOrigin);
            //add to list of layered info, so that re-rendering on change origin can move printed points
            layers.push(layerGroupOrigin)


            const layerGroupOtherPoints = L.layerGroup().addTo(map);
            //Print points saved from phone into database
            points.forEach(c => {


                const localRoomCoordsAsLatLong = localToGeo(c.x, c.z, origin.lat, origin.lon)


                const latLongCoords = rotation === undefined ?
                    localRoomCoordsAsLatLong : rotatePointMap(localRoomCoordsAsLatLong.lat, localRoomCoordsAsLatLong.lon, origin.lat, origin.lon, rotation)




                let circle = L.circle(latLongCoords, {
                    color: matchColorLevel(c.level || c.qualityLevel),
                    fillOpacity: 0.5,
                    radius: 0.05
                }).addTo(layerGroupOtherPoints);
            })
            //add to list of layered info, so that re-rendering on change origin can move printed points
            layers.push(layerGroupOtherPoints)

        }

    </script>





</body>

</html>